class Hatch{constructor(t,s,e,i){this.fullspeed=5,this.opacityLevel=255,this.radiusMin=.001*DOMINANTSIDE,this.radiusMax=.002*DOMINANTSIDE,this.distanceBoost=4,this.buffer=i,this.OkLevel=40,this.fillColor=color(red(e),green(e),blue(e),this.opacityLevel),this.strokeColor=color(red(e),green(e),blue(e),this.opacityLevel),this.strokeColorDistort=10,this.start=t,this.end=s,this.alive=!0,this.passedA=!1,this.passedB=!1,this.pos=this.start.copy(),this.elementCount=1,this.elements=[],this.vel=createVector(0,0,0),this.acc=createVector(0,0,0),this.Distance=p5.Vector.sub(this.end,this.start),this.DistanceLength=this.Distance.mag(),this.distAccSlo=this.DistanceLength/this.distanceBoost,this.boost=this.fullspeed/this.distAccSlo,this.checkpointA=p5.Vector.add(this.start,p5.Vector.div(this.Distance,this.distanceBoost)),this.checkpointB=p5.Vector.sub(this.end,p5.Vector.div(this.Distance,this.distanceBoost)),this.accBoost=p5.Vector.mult(p5.Vector.normalize(this.Distance),this.boost),this.sloBoost=p5.Vector.mult(this.accBoost,-1),this.get_orientation(),this.anglePath=atan2(this.end.y-this.start.y,this.end.x-this.start.x),this.endOrtho=p5.Vector.add(this.end,p5.Vector.fromAngle(this.anglePath-PI/2,100))}get_orientation(){this.acceptanceLevel=PI/12,this.angle=p5.Vector.sub(this.end,this.start).heading(),this.angle>-this.acceptanceLevel&&this.angle<this.acceptanceLevel?this.orientation="left-right":this.angle>PI/4-this.acceptanceLevel&&this.angle<PI/4+this.acceptanceLevel?this.orientation="top/left-bottom/right":this.angle>PI/2-this.acceptanceLevel&&this.angle<PI/2+this.acceptanceLevel?this.orientation="top-bottom":this.angle<-(PI/4-this.acceptanceLevel)&&this.angle>-(PI/4+this.acceptanceLevel)?this.orientation="left/bottom-top/right":(console.warn("some noise with this.angle: "+this.angle),this.orientation="unkown")}get_status(){this.orthoProjectionPoint=orthogonalProjection1(this.end,this.endOrtho,this.pos),this.pos.dist(this.orthoProjectionPoint)<=this.OkLevel&&(this.alive=!1,this.acc=createVector(0,0,0),this.vel=createVector(0,0,0)),this.pos.dist(this.checkpointA)<=2&&(this.passedA=!0),this.pos.dist(this.checkpointB)<=2&&(this.passedB=!0)}update(){this.alive&&(this.get_status(),0==this.passedA?this.acc=this.accBoost:1==this.passedA&&0==this.passedB?this.acc=createVector(0,0,0):1==this.passedA&&1==this.passedB?this.acc=this.sloBoost:this.alive,this.vel.add(this.acc),this.pos.add(this.vel),this.strokeSize=Math.round(100*map(this.vel.mag(),1,3,15,5))/100)}show(){this.drawHatch()}drawHatch(){this.alive&&(this.buffer.push(),this.buffer.strokeWeight(this.strokeSize),this.buffer.stroke(this.strokeColor),this.buffer.noFill(),this.buffer.point(this.pos.x,this.pos.y),this.buffer.pop())}}class hatchSystem{constructor(t,s,e,i,h,a){this.color=a,this.x_start=t,this.y_start=s,this.x_stop=e,this.y_stop=i,this.distance_between_lines=h,this.hatches=[],this.buffer=createGraphics(width,height),this.chosen_axis=getRandomFromList(["yx","xy","x&y"]),this.createHatches(),this.show()}createHatches(){if("x"==this.chosen_axis){this.count_lines=(this.y_stop-this.y_start)/this.distance_between_lines;for(let t=0;t<this.count_lines;t++)this.hatches.push(new Hatch(createVector(this.x_start,this.y_start+this.distance_between_lines*t),createVector(this.x_stop,this.y_start+this.distance_between_lines*t),this.color,this.buffer))}else if("y"==this.chosen_axis){this.count_lines=(this.x_stop-this.x_start)/this.distance_between_lines;for(let t=0;t<this.count_lines;t++)this.hatches.push(new Hatch(createVector(this.x_start+this.distance_between_lines*t,this.y_start),createVector(this.x_start+this.distance_between_lines*t,this.y_stop),this.color,this.buffer))}else if("xy"==this.chosen_axis){this.count_lines=(this.x_stop-this.x_start)/this.distance_between_lines;for(let t=0;t<this.count_lines;t++)this.hatches.push(new Hatch(createVector(this.x_start+this.distance_between_lines*t,this.y_start),createVector(this.x_stop,this.y_stop-this.distance_between_lines*t),this.color,this.buffer));this.count_lines=(this.y_stop-this.y_start)/this.distance_between_lines;for(let t=1;t<this.count_lines;t++)this.hatches.push(new Hatch(createVector(this.x_start,this.y_start+this.distance_between_lines*t),createVector(this.x_stop-this.distance_between_lines*t,this.y_stop),this.color,this.buffer))}else if("yx"==this.chosen_axis){this.count_lines=(this.x_stop-this.x_start)/this.distance_between_lines;for(let t=0;t<this.count_lines;t++)this.hatches.push(new Hatch(createVector(this.x_start+this.distance_between_lines*t,this.y_stop),createVector(this.x_stop,this.y_start+this.distance_between_lines*t),this.color,this.buffer));this.count_lines=(this.y_stop-this.y_start)/this.distance_between_lines;for(let t=1;t<this.count_lines;t++)this.hatches.push(new Hatch(createVector(this.x_start,this.y_stop-this.distance_between_lines*t),createVector(this.x_stop-this.distance_between_lines*t,this.y_start),this.color,this.buffer))}else if("blank"==this.chosen_axis);else if("x&y"==this.chosen_axis){this.count_lines=(this.y_stop-this.y_start)/this.distance_between_lines;for(let t=0;t<this.count_lines;t++)this.hatches.push(new Hatch(createVector(this.x_start,this.y_start+this.distance_between_lines*t),createVector(this.x_stop,this.y_start+this.distance_between_lines*t),this.color,this.buffer));this.count_lines=(this.x_stop-this.x_start)/this.distance_between_lines;for(let t=0;t<this.count_lines;t++)this.hatches.push(new Hatch(createVector(this.x_start+this.distance_between_lines*t,this.y_start),createVector(this.x_start+this.distance_between_lines*t,this.y_stop),this.color,this.buffer))}}add(t){this.hatches.push(t)}show(){for(;0==this.check_all_complete();)for(var t of this.hatches)t.update(),t.show()}check_all_complete(){if(0==this.all_lines_complete||this.hatches.length>0){for(var t of(this.hatches_alive_status=[],this.hatches))this.hatches_alive_status.push(t.alive);return this.hatches_alive_status.every((t=>!1===t))}return!1}}